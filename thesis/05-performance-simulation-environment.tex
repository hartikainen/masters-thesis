\chapter{Performance Simulation Environment}
\label{chapter:performance-simulation-environment}

This chapter describes Performance Simulation Environment (PSE) and its usage for performance analysis of a stream computing system. We begin with an overview of PSE tools and concepts, and continue by describing the three components of a PSE model. After that, we go through the simulation and monitoring of PSE applications. Finally, we address the problems and deficiencies, namely the lack of global queue scheduling, that needed to be resolved before PSE could be used for performance analysis of a stream computing system.

\section{Toolset Overview}
\label{sec:toolset-overview}

PSE is a toolset and simulation environment for dynamic performance analysis of, initially designed but not limited to, parallel computing systems. The tools consist of graphical model editors, compiler tools, and discrete event simulator runtime.

\begin{figure}[ht]
  \begin{center}
    %% \input{images/pse-toolset.tex}
    \missingfigure{\Huge pse toolset overview}
    \caption{PSE toolset includes the model editors, compiler tools and the simulator runtime libraries.}
    \label{fig:pse-toolset}
  \end{center}
\end{figure}

The graphical model editors -- workload editor, wle; task graph editor, tge; sequence chart editor, sce; and resource network editor, rne -- are used to build and edit the PSE model representation of a system. Each model editor has a corresponding compiler (wlc, tgc, scc, and rnc, respectively), that is used to compile the textual model representations into C-code.

The generated model code and the built-in simulator runtime libraries are compiled into an executable simulator program, using generic C compiler such as GCC~\cite{stallman:2009:gcc}. The resulting program can be run on top of Linux operating system on commodity hardware.

\todo[inline]{yadayada}
\todo[inline]{What can be modeled?? What can't be?}
\todo[inline]{Reusability}
\todo[inline]{Model represents a system.}
\todo[inline]{In PSE, the simulation model is created by graphical user interfaces. Internally the model is presented as a simple text format that is then parsed by tgc.}

\section{PSE Model}

In PSE, the system under study is modeled as a resource network~\cite{Menasce:1994:CPP:174466}. The complete model consists of three main components: resource provision model, resource usage model and workload model. Each of the components are presented as directed graphs, where the nodes represent model entities and the arcs represent the possible flow directions of the tasks.

The resource provision model represents the available system resources, for example a computer hardware. The graph nodes represent resource entities, and arcs represent the possible usage order of the resources. The resources are consumed by the tasks generated by the workload model.

A resource can be either active or passive. Active resources provide service and introduce service delay to the tasks using them. An example of active resource could be a processor core, which can serve certain amount of processing cycles per unit time. Passive resources do not induce direct delay to the jobs, but their possession is required to access certain other resources. Locks \todo{cite something} could be an example of passive resource.

\begin{figure}[h!]
  \begin{center}
    \missingfigure{\Huge resource provision model?}
    % \includegraphics[width=\textwidth]{images/.pdf}
    \caption{An example of resource provision model.}
    \label{fig:resource-provision-model}
  \end{center}

\end{figure}

Figure \ref{fig:resource-provision-model} presents an example of a resource provision model ...
\todo[inline]{Explain the figure}

The resource usage models can be represented as message sequence charts or tasks graphs. We omit the discussion of the sequence chart in this thesis. A task graph is a representation of the resource usage of the tasks arriving to the system. The nodes in the task graph can be divided into three categories: execution nodes describe the resource usage events and activities, branching nodes conditionally guide the tasks through the graph, and fork/join nodes represent task subdivision. The arcs represent the flow of control in the system.

\begin{figure}[h!]
  \begin{center}
    \missingfigure{\Huge resource usage model?}
    % \includegraphics[width=\textwidth]{images/.pdf}
    \caption{An example of resource usage model.}
    \label{fig:resource-usage-model}
  \end{center}
\end{figure}

Figure \ref{fig:resource-usage-model} presents an example of a resource usage model ...
\todo[inline]{Explain the figure}

The workload model generates tasks, which traverse through the system according to the rules defined in the resource usage model, consuming the resources defined in the resource provision model. The nodes in the workload graph describe the task generating processes, and the arcs define the relationships between them. The graph representing the workload model must be acyclic.

The event spawn rate can be constant or random (specified for example with probability distribution).

When an event is spawned, it progresses through the resource provision model triggering the resource usages. -> gets delayed.

\begin{figure}[h]
  \begin{center}
    % \includegraphics[width=\textwidth]{images/rne-example.pdf}
    \caption{The graphical user interface of the resource network editor. The actual resource network model is presented in the middle, and the toolbar on the left.}
    \label{fig:rne-example}
  \end{center}
\end{figure}

\section{Monitoring}

PSE has flexible, built-in, monitoring support which offers both trace-based and on-the-fly monitoring. The monitoring is controlled by attaching probes to the nodes and vertices of the simulation model nodes. or vertices. It can be done on all the three model levels and practically every simulation system state change can be captured. There are essentially two different types of probes in PSE: the trace probes for trace-based measurements, and the metric probes for on-the-fly measurements.

In the resource provision model, the probes can be attached to two different parts of the resourse, to measure either the resource utilization, or its queue size. The trace probes capture every change in the resource utilization or queue size, whereas the metric trace produce aggregate only the descriptive statistics. The metric statistics currently include mean, standard deviation, mininimum, maximum, sum, and total number of tasks that passed through.

In the resource usage model, the probes can be attached to the model edges, producing a timestamped trace whenever a task travels the edge. The timing can be either absolute time with respect to the global system time, or relative to the process start time. The metric probes can be used to capture the averates times of all tasks relative to the start of the process. Probes in the workload model are used to control the grouping of the resource usage and resource provision probes.

The probe output is written in a text file defined in the probe node attributes. The trace probes write the output in Comma-Separated Values~\cite{https://tools.ietf.org/html/rfc4180} format, and the metrics traces write a standard descriptive statistics output. Using the trace based probing can substantially slow down the simulation, as the output files easily grow very large, slowing down the writes. Thus, whenever the complete trace log is not needed, it is recommended to use the metric based probing.

\todo[inline]{present an example of probes}

\section{Resource Network Simulator}
\label{sec:resource-network-simulator}

Performance Simulation Environment provides a discrete event simulator engine, named resource network simulator (RNS). The final simulator program is created by compiling the RNS runtime libraries together with the generated simulation model code. The simulator engine manages the simulation execution, i.e. it tracks the global simulation time, schedules tasks and manages the system monitoring.

The simulator inputs are generated by the workload model, which spawns a new system thread for each generated input. The input can be either control input or the actual workload tasks. The former of these are used for the simulation control, for example changing or resetting the simulation time or monitoring metrics. The latter are the actual task entities presented in section~\ref{sec:simulation-model}.

\todo[inline]{how to present this thing? service routines vs. engine? Should the RNS code be in the appendix?}

\subsection{RNS Service Routines}
\label{sec:rns-service-routines}

\lstinputlisting[caption=RNS\_use\_device,
                 label=lst:RNS-use-device]{listings/RNS_use_device.c}

RNS\_use\_device in~\ref{lst:RNS-use-device} reserves the resource, delays the process (i.e. the task) and releases the resource for other processes.

\lstinputlisting[caption=RNS\_demand\_device,
                 label=lst:RNS-demand-device]{listings/RNS_demand_device.c}

RNS\_demand\_device routine in~\ref{lst:RNS-demand-device} is a simple wrapper routine, that converts the demanded service amount (service\_amount) into corresponding service time, based on the device entity speed (d-$\textgreater$speed). It then calls the RNS\_use\_device routine with the resulting service time.

\lstinputlisting[caption=RNS\_reserve\_resource,
                 label=lst:RNS-reserve-resource]{listings/RNS_reserve_resource.c}

\ref{lst:RNS-reserve-resource} summarizes the RNS\_reserve\_resource routine. RNS\_reserve\_resource calls the reserve function bound to the resource entity as explained in section \ref{TODO}. The reserve function assigns the task either in the resource's processing queue or waiting queue.

If the reserve function assigns the task to the waiting queue, the thread yields the execution to the scheduler.

\lstinputlisting[caption=RNS\_delay\_process,
                 label=lst:RNS-delay-process]{listings/RNS_delay_process.c}
\lstinputlisting[caption=RNS\_release\_resource,
                 label=lst:RNS-release-resource]{listings/RNS_release_resource.c}

\subsection{Simulator Engine}
\label{sec:simulator-engine}

\begin{figure}[ht]
  \begin{center}
    %\includegraphics[width=\textwidth]{images/rns-threads.pdf}
    \caption{PSE thread usage}
    \label{fig:rns-threads}
  \end{center}
\end{figure}

RNS advances in the event-advance manner. Each time a thread's task encounters an event that is dependent on the other threads' execution, it yields the execution to the scheduler thread, which then signals the thread with the smallest trigger time.

The thread (task) with the smallest trigger time gets run when the previous running thread has yielded execution.


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "thesis-hartikainen"
%%% End:
